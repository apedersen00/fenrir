// =============================================================================
// File: tb_convolution_reusable.sv
// Description: Simplified testbench with pure memory dumps - no calculations
// =============================================================================

import snn_interfaces_pkg::*;

module tb_convolution_reusable;

    // Include test configuration (generated by Python)
    `include "test_events_config.sv"  // Contains NUM_TEST_EVENTS, file names, etc.

    // Testbench parameters
    localparam int COORD_BITS = 8;
    localparam int IMG_WIDTH = TEST_IMG_WIDTH;
    localparam int IMG_HEIGHT = TEST_IMG_HEIGHT;
    localparam int CHANNELS = 1;
    localparam int BITS_PER_CHANNEL = 9;
    localparam int FIFO_DATA_WIDTH = 2 * COORD_BITS;
    localparam int INPUT_FIFO_EVENT_CAPACITY = 512;
    localparam int INPUT_FIFO_ADDR_WIDTH = $clog2(INPUT_FIFO_EVENT_CAPACITY);
    localparam int BRAM_DATA_WIDTH = CHANNELS * BITS_PER_CHANNEL;
    localparam int BRAM_ADDR_WIDTH = $clog2(IMG_WIDTH * IMG_HEIGHT);

    // Clock and reset
    logic clk = 0;
    logic rst_n;
    always #5 clk = ~clk;

    // DUT control signals
    logic sys_enable;
    logic sys_reset;
    logic timestep;
    logic system_active;
    logic fifo_empty;
    logic fifo_full;
    logic [FIFO_DATA_WIDTH-1:0] spike_event;
    logic write_enable;
    logic output_fifo_full;

    // Test event storage
    logic [15:0] test_events [0:NUM_TEST_EVENTS-1];
    int events_loaded;

    // DUT instantiation
    fast_conv_controller #(
        .COORD_BITS(COORD_BITS),
        .IMG_WIDTH(IMG_WIDTH),
        .IMG_HEIGHT(IMG_HEIGHT),
        .CHANNELS(CHANNELS),
        .BITS_PER_CHANNEL(BITS_PER_CHANNEL),
        .FIFO_DATA_WIDTH(FIFO_DATA_WIDTH),
        .INPUT_FIFO_EVENT_CAPACITY(INPUT_FIFO_EVENT_CAPACITY),
        .INPUT_FIFO_ADDR_WIDTH(INPUT_FIFO_ADDR_WIDTH),
        .BRAM_DATA_WIDTH(BRAM_DATA_WIDTH),
        .BRAM_ADDR_WIDTH(BRAM_ADDR_WIDTH)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),
        .sys_enable(sys_enable),
        .sys_reset(sys_reset),
        .timestep(timestep),
        .system_active(system_active),
        .fifo_empty(fifo_empty),
        .fifo_full(fifo_full),
        .spike_event(spike_event),
        .write_enable(write_enable),
        .output_fifo_full(output_fifo_full)
    );

    // =========================================================================
    // Load test events from file
    // =========================================================================
    
    task automatic load_test_events();
        $display("Loading test events from %s...", TEST_EVENTS_FILE);
        
        // Load events using $readmemh
        $readmemh(TEST_EVENTS_FILE, test_events);
        
        // Count how many events were actually loaded
        events_loaded = 0;
        for (int i = 0; i < NUM_TEST_EVENTS; i++) begin
            if (!$isunknown(test_events[i])) begin
                events_loaded++;
            end else begin
                break;
            end
        end
        
        $display("Loaded %0d events (expected %0d)", events_loaded, NUM_TEST_EVENTS);
        
        if (events_loaded != NUM_TEST_EVENTS) begin
            $warning("Event count mismatch! Check your event file.");
        end
        
        // Show first few events for verification
        $display("First few events:");
        for (int i = 0; i < 5 && i < events_loaded; i++) begin
            automatic logic [7:0] x = test_events[i][15:8];
            automatic logic [7:0] y = test_events[i][7:0];
            $display("  Event[%0d]: (%0d, %0d) = 0x%04h", i, x, y, test_events[i]);
        end
    endtask

    // =========================================================================
    // PURE Memory Dump Function - No calculations, just raw memory
    // =========================================================================
    
    task automatic dump_memory_after_event(input int event_num);
        automatic string filename;
        automatic int file_handle;
        
        filename = $sformatf("memory_dump_event_%0d.csv", event_num);
        file_handle = $fopen(filename, "w");
        
        if (file_handle == 0) begin
            $error("Failed to open memory dump file: %s", filename);
            return;
        end
        
        $display("T=%0t: Dumping memory to %s...", $time, filename);
        
        // Write simple CSV header
        $fwrite(file_handle, "addr,ch0\n");
        
        // Dump ALL memory locations - pure raw dump
        for (int addr = 0; addr < (IMG_WIDTH * IMG_HEIGHT); addr++) begin
            automatic logic [BRAM_DATA_WIDTH-1:0] raw_data = dut.feature_map_memory.memory[addr];
            
            // Write address
            $fwrite(file_handle, "%0d", addr);
            
            // Extract and write each channel - simple bit slicing
            for (int ch = 0; ch < CHANNELS; ch++) begin
                automatic logic [BITS_PER_CHANNEL-1:0] channel_bits = 
                    raw_data[ch*BITS_PER_CHANNEL +: BITS_PER_CHANNEL];
                
                // Convert to signed integer for output
                automatic int signed channel_value = $signed(channel_bits);
                $fwrite(file_handle, ",%0d", channel_value);
            end
            
            $fwrite(file_handle, "\n");
        end
        
        $fclose(file_handle);
        $display("Memory dump complete: %s", filename);
    endtask

    // =========================================================================
    // Main test sequence - SIMPLIFIED
    // =========================================================================
    
    initial begin
        $display("=== Pure Memory Dump Testbench ===");
        $display("Configuration: %0dx%0d image, %0d channels, %0d events", 
                 IMG_WIDTH, IMG_HEIGHT, CHANNELS, NUM_TEST_EVENTS);
        
        // Initialize signals
        rst_n = 0;
        sys_enable = 0;
        sys_reset = 1;
        timestep = 0;
        spike_event = 0;
        write_enable = 0;
        output_fifo_full = 0;

        // Load test events from file
        load_test_events();
        
        // Reset sequence
        #50;
        rst_n = 1;
        sys_reset = 0;
        sys_enable = 1;
        #20;
        
        $display("T=%0t: System initialized", $time);
        
        // Dump initial memory state (should be all zeros)
        dump_memory_after_event(0);
        
        // Process each loaded event
        for (int event_idx = 0; event_idx < events_loaded; event_idx++) begin
            
            // Unpack event coordinates
            automatic logic [7:0] event_x = test_events[event_idx][15:8];
            automatic logic [7:0] event_y = test_events[event_idx][7:0];
            
            $display("\n=== Processing Event %0d/%0d: (%0d,%0d) ===", 
                     event_idx+1, events_loaded, event_x, event_y);
            
            // Send event to FIFO
            @(posedge clk);
            spike_event = {event_x, event_y};
            write_enable = 1;
            
            $display("T=%0t: Sending event (%0d,%0d) to FIFO", $time, event_x, event_y);
            
            @(posedge clk);
            write_enable = 0;
            
            // Wait for system to process the event
            $display("T=%0t: Waiting for convolution to complete...", $time);
            
            // Wait for system to become active
            wait(system_active == 1'b1);
            $display("T=%0t: System active - processing event", $time);
            
            // Wait for system to become inactive (processing complete)
            wait(system_active == 1'b0);
            $display("T=%0t: Convolution complete for event %0d", $time, event_idx);
            
            // Give a few extra cycles for signals to settle
            repeat(5) @(posedge clk);
            
            // Dump memory state after this event
            dump_memory_after_event(event_idx + 1);
            
            // Small delay between events
            repeat(10) @(posedge clk);
        end
        
        $display("\n=== All %0d events processed successfully! ===", events_loaded);
        
        // Simulation complete
        #100;
        $display("=== Pure Memory Dump Complete ===");
        $display("Memory dumps saved as: memory_dump_event_*.csv");
        $finish;
    end

    // =========================================================================
    // Simple monitoring
    // =========================================================================
    
    // Monitor convolution state changes
    always @(posedge clk) begin
        if (dut.fast_conv_inst.state != dut.fast_conv_inst.next_state) begin
            $display("T=%0t: CONV State: %s â†’ %s", 
                     $time, 
                     dut.fast_conv_inst.state.name(), 
                     dut.fast_conv_inst.next_state.name());
        end
    end
    
    // Monitor when events are being processed
    always @(posedge clk) begin
        if (dut.fast_conv_inst.state == dut.fast_conv_inst.PROCESSING) begin
            if (dut.fast_conv_inst.mem_read.read_req && dut.fast_conv_inst.mem_write.write_req) begin
                $display("T=%0t: CONV Processing coord (%0d,%0d)", 
                         $time,
                         dut.fast_conv_inst.mem_read.coord_get.x,
                         dut.fast_conv_inst.mem_read.coord_get.y);
            end
        end
    end
    
    // Basic error checking
    always @(posedge clk) begin
        if (fifo_full && write_enable) begin
            $warning("T=%0t: Attempting to write to full FIFO!", $time);
        end
        
        if ($isunknown(system_active)) begin
            $error("T=%0t: system_active is X/Z!", $time);
        end
    end

endmodule